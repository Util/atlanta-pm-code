.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::Provider 3"
.TH Template::Provider 3 "2007-04-27" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Provider \- Provider module for loading/compiling templates
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    $provider = Template::Provider\->new(\e%options);
\&
\&    ($template, $error) = $provider\->fetch($name);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Template::Provider is used to load, parse, compile and cache template
documents.  This object may be sub-classed to provide more specific 
facilities for loading, or otherwise providing access to templates.
.PP
The Template::Context objects maintain a list of Template::Provider 
objects which are polled in turn (via \fIfetch()\fR) to return a requested
template.  Each may return a compiled template, raise an error, or 
decline to serve the request, giving subsequent providers a chance to
do so.
.PP
This is the \*(L"Chain of Responsibility\*(R" pattern.  See 'Design Patterns' for
further information.
.PP
The Template::Provider can also be subclassed to provide templates from
a different source, e.g. a database. See \s-1SUBCLASSING\s0 below.
.PP
This documentation needs work.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.Sh "new(\e%options)"
.IX Subsection "new(%options)"
Constructor method which instantiates and returns a new Template::Provider
object.  The optional parameter may be a hash reference containing any of
the following items:
.IP "\s-1INCLUDE_PATH\s0" 4
.IX Item "INCLUDE_PATH"
The \s-1INCLUDE_PATH\s0 is used to specify one or more directories in which
template files are located.  When a template is requested that isn't
defined locally as a \s-1BLOCK\s0, each of the \s-1INCLUDE_PATH\s0 directories is
searched in turn to locate the template file.  Multiple directories
can be specified as a reference to a list or as a single string where
each directory is delimited by ':'.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        INCLUDE_PATH => '/usr/local/templates',
\&    });
\&  
\&    my $provider = Template::Provider\->new({
\&        INCLUDE_PATH => '/usr/local/templates:/tmp/my/templates',
\&    });
\&  
\&    my $provider = Template::Provider\->new({
\&        INCLUDE_PATH => [ '/usr/local/templates', 
\&                          '/tmp/my/templates' ],
\&    });
.Ve
.Sp
On Win32 systems, a little extra magic is invoked, ignoring delimiters
that have ':' followed by a '/' or '\e'.  This avoids confusion when using
directory names like 'C:\eBlah Blah'.
.Sp
When specified as a list, the \s-1INCLUDE_PATH\s0 path can contain elements 
which dynamically generate a list of \s-1INCLUDE_PATH\s0 directories.  These 
generator elements can be specified as a reference to a subroutine or 
an object which implements a \fIpaths()\fR method.
.Sp
.Vb 5
\&    my $provider = Template::Provider\->new({
\&        INCLUDE_PATH => [ '/usr/local/templates', 
\&                          \e&incpath_generator, 
\&                          My::IncPath::Generator\->new( ... ) ],
\&    });
.Ve
.Sp
Each time a template is requested and the \s-1INCLUDE_PATH\s0 examined, the
subroutine or object method will be called.  A reference to a list of
directories should be returned.  Generator subroutines should report
errors using \fIdie()\fR.  Generator objects should return undef and make an
error available via its \fIerror()\fR method.
.Sp
For example:
.Sp
.Vb 1
\&    sub incpath_generator {
\&
\&        # ...some code...
\&        
\&        if ($all_is_well) {
\&            return \e@list_of_directories;
\&        }
\&        else {
\&            die "cannot generate INCLUDE_PATH...\en";
\&        }
\&    }
.Ve
.Sp
or:
.Sp
.Vb 1
\&    package My::IncPath::Generator;
\&
\&    # Template::Base (or Class::Base) provides error() method
\&    use Template::Base;
\&    use base qw( Template::Base );
\&
\&    sub paths {
\&        my $self = shift;
\&
\&        # ...some code...
\&
\&        if ($all_is_well) {
\&            return \e@list_of_directories;
\&        }
\&        else {
\&            return $self\->error("cannot generate INCLUDE_PATH...\en");
\&        }
\&    }
\&
\&    1;
.Ve
.IP "\s-1DELIMITER\s0" 4
.IX Item "DELIMITER"
Used to provide an alternative delimiter character sequence for 
separating paths specified in the \s-1INCLUDE_PATH\s0.  The default
value for \s-1DELIMITER\s0 is ':'.
.Sp
.Vb 5
\&    # tolerate Silly Billy's file system conventions
\&    my $provider = Template::Provider\->new({
\&        DELIMITER    => '; ',
\&        INCLUDE_PATH => 'C:/HERE/NOW; D:/THERE/THEN',
\&    });
\&
\&    # better solution: install Linux!  :\-)
.Ve
.Sp
On Win32 systems, the default delimiter is a little more intelligent,
splitting paths only on ':' characters that aren't followed by a '/'.
This means that the following should work as planned, splitting the 
\&\s-1INCLUDE_PATH\s0 into 2 separate directories, C:/foo and C:/bar.
.Sp
.Vb 4
\&    # on Win32 only
\&    my $provider = Template::Provider\->new({
\&        INCLUDE_PATH => 'C:/Foo:C:/Bar'
\&    });
.Ve
.Sp
However, if you're using Win32 then it's recommended that you
explicitly set the \s-1DELIMITER\s0 character to something else (e.g. ';')
rather than rely on this subtle magic.
.IP "\s-1ABSOLUTE\s0" 4
.IX Item "ABSOLUTE"
The \s-1ABSOLUTE\s0 flag is used to indicate if templates specified with
absolute filenames (e.g. '/foo/bar') should be processed.  It is
disabled by default and any attempt to load a template by such a
name will cause a 'file' exception to be raised.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        ABSOLUTE => 1,
\&    });
\&
\&    # this is why it's disabled by default
\&    [% INSERT /etc/passwd %]
.Ve
.Sp
On Win32 systems, the regular expression for matching absolute 
pathnames is tweaked slightly to also detect filenames that start
with a driver letter and colon, such as:
.Sp
.Vb 1
\&    C:/Foo/Bar
.Ve
.IP "\s-1RELATIVE\s0" 4
.IX Item "RELATIVE"
The \s-1RELATIVE\s0 flag is used to indicate if templates specified with
filenames relative to the current directory (e.g. './foo/bar' or
\&'../../some/where/else') should be loaded.  It is also disabled by
default, and will raise a 'file' error if such template names are
encountered.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        RELATIVE => 1,
\&    });
\&
\&    [% INCLUDE ../logs/error.log %]
.Ve
.IP "\s-1DEFAULT\s0" 4
.IX Item "DEFAULT"
The \s-1DEFAULT\s0 option can be used to specify a default template which should 
be used whenever a specified template can't be found in the \s-1INCLUDE_PATH\s0.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        DEFAULT => 'notfound.html',
\&    });
.Ve
.Sp
If a non-existant template is requested through the Template \fIprocess()\fR
method, or by an \s-1INCLUDE\s0, \s-1PROCESS\s0 or \s-1WRAPPER\s0 directive, then the
\&\s-1DEFAULT\s0 template will instead be processed, if defined.  Note that the
\&\s-1DEFAULT\s0 template is not used when templates are specified with
absolute or relative filenames, or as a reference to a input file
handle or text string.
.IP "\s-1CACHE_SIZE\s0" 4
.IX Item "CACHE_SIZE"
The Template::Provider module caches compiled templates to avoid the need
to re-parse template files or blocks each time they are used.  The \s-1CACHE_SIZE\s0
option is used to limit the number of compiled templates that the module
should cache.
.Sp
By default, the \s-1CACHE_SIZE\s0 is undefined and all compiled templates are
cached.  When set to any positive value, the cache will be limited to
storing no more than that number of compiled templates.  When a new
template is loaded and compiled and the cache is full (i.e. the number
of entries == \s-1CACHE_SIZE\s0), the least recently used compiled template
is discarded to make room for the new one.
.Sp
The \s-1CACHE_SIZE\s0 can be set to 0 to disable caching altogether.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        CACHE_SIZE => 64,   # only cache 64 compiled templates
\&    });
\&
\&    my $provider = Template::Provider\->new({
\&        CACHE_SIZE => 0,   # don't cache any compiled templates
\&    });
.Ve
.Sp
As well as caching templates as they are found, the Template::Provider
also implements negative caching to keep track of templates that are 
\&\fInot\fR found.  This allows the provider to quickly decline a request
for a template that it has previously failed to locate, saving the effort
of going to look for it again.  This is useful when an \s-1INCLUDE_PATH\s0 includes 
multiple providers, ensuring that the request is passed down through the 
providers as quickly as possible.
.IP "\s-1STAT_TTL\s0" 4
.IX Item "STAT_TTL"
This value can be set to control how long the Template::Provider will keep a
template cached in memory before checking to see if the source template has
changed.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        STAT_TTL => 60,  # one minute
\&    });
.Ve
.Sp
The default value is 1 (second). You'll probably want to set this to a higher
value if you're running the Template Toolkit inside a persistent web server
application (e.g. mod_perl). For example, set it to 60 and the provider will
only look for changes to templates once a minute at most. However, during
development (or any time you're making frequent changes to templates) you'll
probably want to keep it set to a low value so that you don't have to wait
for the provider to notice that your templates have changed.
.IP "\s-1COMPILE_EXT\s0" 4
.IX Item "COMPILE_EXT"
From version 2 onwards, the Template Toolkit has the ability to
compile templates to Perl code and save them to disk for subsequent
use (i.e. cache persistence).  The \s-1COMPILE_EXT\s0 option may be
provided to specify a filename extension for compiled template files.
It is undefined by default and no attempt will be made to read or write 
any compiled template files.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        COMPILE_EXT => '.ttc',
\&    });
.Ve
.Sp
If \s-1COMPILE_EXT\s0 is defined (and \s-1COMPILE_DIR\s0 isn't, see below) then compiled
template files with the \s-1COMPILE_EXT\s0 extension will be written to the same
directory from which the source template files were loaded.
.Sp
Compiling and subsequent reuse of templates happens automatically
whenever the \s-1COMPILE_EXT\s0 or \s-1COMPILE_DIR\s0 options are set.  The Template
Toolkit will automatically reload and reuse compiled files when it 
finds them on disk.  If the corresponding source file has been modified
since the compiled version as written, then it will load and re-compile
the source and write a new compiled version to disk.
.Sp
This form of cache persistence offers significant benefits in terms of 
time and resources required to reload templates.  Compiled templates can
be reloaded by a simple call to Perl's \fIrequire()\fR, leaving Perl to handle
all the parsing and compilation.  This is a Good Thing.
.IP "\s-1COMPILE_DIR\s0" 4
.IX Item "COMPILE_DIR"
The \s-1COMPILE_DIR\s0 option is used to specify an alternate directory root
under which compiled template files should be saved.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        COMPILE_DIR => '/tmp/ttc',
\&    });
.Ve
.Sp
The \s-1COMPILE_EXT\s0 option may also be specified to have a consistent file
extension added to these files.
.Sp
.Vb 4
\&    my $provider1 = Template::Provider\->new({
\&        COMPILE_DIR => '/tmp/ttc',
\&        COMPILE_EXT => '.ttc1',
\&    });
\&
\&    my $provider2 = Template::Provider\->new({
\&        COMPILE_DIR => '/tmp/ttc',
\&        COMPILE_EXT => '.ttc2',
\&    });
.Ve
.Sp
When \s-1COMPILE_EXT\s0 is undefined, the compiled template files have the
same name as the original template files, but reside in a different
directory tree.
.Sp
Each directory in the \s-1INCLUDE_PATH\s0 is replicated in full beneath the 
\&\s-1COMPILE_DIR\s0 directory.  This example:
.Sp
.Vb 4
\&    my $provider = Template::Provider\->new({
\&        COMPILE_DIR  => '/tmp/ttc',
\&        INCLUDE_PATH => '/home/abw/templates:/usr/share/templates',
\&    });
.Ve
.Sp
would create the following directory structure:
.Sp
.Vb 2
\&    /tmp/ttc/home/abw/templates/
\&    /tmp/ttc/usr/share/templates/
.Ve
.Sp
Files loaded from different \s-1INCLUDE_PATH\s0 directories will have their
compiled forms save in the relevant \s-1COMPILE_DIR\s0 directory.
.Sp
On Win32 platforms a filename may by prefixed by a drive letter and
colon.  e.g.
.Sp
.Vb 1
\&    C:/My Templates/header
.Ve
.Sp
The colon will be silently stripped from the filename when it is added
to the \s-1COMPILE_DIR\s0 value(s) to prevent illegal filename being generated.
Any colon in \s-1COMPILE_DIR\s0 elements will be left intact.  For example:
.Sp
.Vb 6
\&    # Win32 only
\&    my $provider = Template::Provider\->new({
\&        DELIMITER    => ';',
\&        COMPILE_DIR  => 'C:/TT2/Cache',
\&        INCLUDE_PATH => 'C:/TT2/Templates;D:/My Templates',
\&    });
.Ve
.Sp
This would create the following cache directories:
.Sp
.Vb 2
\&    C:/TT2/Cache/C/TT2/Templates
\&    C:/TT2/Cache/D/My Templates
.Ve
.IP "\s-1TOLERANT\s0" 4
.IX Item "TOLERANT"
The \s-1TOLERANT\s0 flag is used by the various Template Toolkit provider
modules (Template::Provider, Template::Plugins, Template::Filters) to
control their behaviour when errors are encountered.  By default, any
errors are reported as such, with the request for the particular
resource (template, plugin, filter) being denied and an exception
raised.  When the \s-1TOLERANT\s0 flag is set to any true values, errors will
be silently ignored and the provider will instead return
\&\s-1STATUS_DECLINED\s0.  This allows a subsequent provider to take
responsibility for providing the resource, rather than failing the
request outright.  If all providers decline to service the request,
either through tolerated failure or a genuine disinclination to
comply, then a '<resource> not found' exception is raised.
.IP "\s-1PARSER\s0" 4
.IX Item "PARSER"
The Template::Parser module implements a parser object for compiling
templates into Perl code which can then be executed.  A default object
of this class is created automatically and then used by the
Template::Provider whenever a template is loaded and requires 
compilation.  The \s-1PARSER\s0 option can be used to provide a reference to 
an alternate parser object.
.Sp
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        PARSER => MyOrg::Template::Parser\->new({ ... }),
\&    });
.Ve
.IP "\s-1DEBUG\s0" 4
.IX Item "DEBUG"
The \s-1DEBUG\s0 option can be used to enable debugging messages from the
Template::Provider module by setting it to include the \s-1DEBUG_PROVIDER\s0
value.
.Sp
.Vb 1
\&    use Template::Constants qw( :debug );
\&
\&    my $template = Template\->new({
\&        DEBUG => DEBUG_PROVIDER,
\&    });
.Ve
.Sh "fetch($name)"
.IX Subsection "fetch($name)"
Returns a compiled template for the name specified.  If the template 
cannot be found then (undef, \s-1STATUS_DECLINED\s0) is returned.  If an error
occurs (e.g. read error, parse error) then ($error, \s-1STATUS_ERROR\s0) is 
returned, where \f(CW$error\fR is the error message generated.  If the \s-1TOLERANT\s0
flag is set the the method returns (undef, \s-1STATUS_DECLINED\s0) instead of
returning an error.
.ie n .Sh "store($name, $template)"
.el .Sh "store($name, \f(CW$template\fP)"
.IX Subsection "store($name, $template)"
Stores the compiled template, \f(CW$template\fR, in the cache under the name, 
\&\f(CW$name\fR.  Susbequent calls to fetch($name) will return this template in
preference to any disk-based file.
.Sh "include_path(\e@newpath))"
.IX Subsection "include_path(@newpath))"
Accessor method for the \s-1INCLUDE_PATH\s0 setting.  If called with an
argument, this method will replace the existing \s-1INCLUDE_PATH\s0 with
the new value.
.Sh "\fIpaths()\fP"
.IX Subsection "paths()"
This method generates a copy of the \s-1INCLUDE_PATH\s0 list.  Any elements in the
list which are dynamic generators (e.g. references to subroutines or objects
implementing a \fIpaths()\fR method) will be called and the list of directories 
returned merged into the output list.
.PP
It is possible to provide a generator which returns itself, thus sending
this method into an infinite loop.  To detect and prevent this from happening,
the \f(CW$MAX_DIRS\fR package variable, set to 64 by default, limits the maximum
number of paths that can be added to, or generated for the output list.  If
this number is exceeded then the method will immediately return an error 
reporting as much.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
The Template::Provider module can be subclassed to provide templates from a 
different source (e.g. a database).  In most cases you'll just need to provide
custom implementations of the \f(CW\*(C`_template_modified()\*(C'\fR and \f(CW\*(C`_template_content()\*(C'\fR
methods.  If your provider requires and custom initialisation then you'll also
need to implement a new \f(CW\*(C`_init()\*(C'\fR method.
.PP
Caching in memory and on disk will still be applied (if enabled)
when overriding these methods.
.IP "_template_modified($path)" 4
.IX Item "_template_modified($path)"
Returns a timestamp of the \f(CW$path\fR passed in by calling \fIstat()\fR.
This can be overridden, for example, to return a last modified value from
a database.  The value returned should be a timestamp value (as returned by \f(CW\*(C`time()\*(C'\fR,
although a sequence number should work as well.
.IP "_template_content($path)" 4
.IX Item "_template_content($path)"
This method returns the content of the template for all \s-1INCLUDE\s0, \s-1PROCESS\s0,
and \s-1INSERT\s0 directives.
.Sp
When called in scalar context, the method returns the content of the template
located at \f(CW$path\fR, or undef if \f(CW$path\fR is not found.
.Sp
When called in list context it returns \f(CW\*(C`($content, $error, $mtime)\*(C'\fR,
where \f(CW$content\fR is the template content, \f(CW$error\fR is an error string
(e.g. \*(L"$path: File not found\*(R"), and \f(CW$mtime\fR is the template modification
time.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org>
.PP
<http://wardley.org/|http://wardley.org/>
.SH "VERSION"
.IX Header "VERSION"
2.93, distributed as part of the
Template Toolkit version 2.19, released on 27 April 2007.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&  Copyright (C) 1996\-2007 Andy Wardley.  All Rights Reserved.
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Parser, Template::Context
