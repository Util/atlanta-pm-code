.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::Context 3"
.TH Template::Context 3 "2007-04-27" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Context \- Runtime context in which templates are processed
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Template::Context;
\&
\&    # constructor
\&    $context = Template::Context\->new(\e%config)
\&        || die $Template::Context::ERROR;
\&
\&    # fetch (load and compile) a template
\&    $template = $context\->template($template_name);
\&
\&    # fetch (load and instantiate) a plugin object
\&    $plugin = $context\->plugin($name, \e@args);
\&
\&    # fetch (return or create) a filter subroutine
\&    $filter = $context\->filter($name, \e@args, $alias);
\&
\&    # process/include a template, errors are thrown via die()
\&    $output = $context\->process($template, \e%vars);
\&    $output = $context\->include($template, \e%vars);
\&
\&    # raise an exception via die()
\&    $context\->throw($error_type, $error_message, \e$output_buffer);
\&
\&    # catch an exception, clean it up and fix output buffer
\&    $exception = $context\->catch($exception, \e$output_buffer);
\&
\&    # save/restore the stash to effect variable localisation
\&    $new_stash = $context\->localise(\e%vars);
\&    $old_stash = $context\->delocalise();
\&
\&    # add new BLOCK or FILTER definitions
\&    $context\->define_block($name, $block);
\&    $context\->define_filter($name, \e&filtersub, $is_dynamic);
\&
\&    # reset context, clearing any imported BLOCK definitions
\&    $context\->reset();
\&
\&    # methods for accessing internal items
\&    $stash     = $context\->stash();
\&    $tflag     = $context\->trim();
\&    $epflag    = $context\->eval_perl();
\&    $providers = $context\->templates();
\&    $providers = $context\->plugins();
\&    $providers = $context\->filters();
\&    ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Template::Context module defines an object class for representing
a runtime context in which templates are processed.  It provides an
interface to the fundamental operations of the Template Toolkit
processing engine through which compiled templates (i.e. Perl code
constructed from the template source) can process templates, load
plugins and filters, raise exceptions and so on.
.PP
A default Template::Context object is created by the Template module.
Any Template::Context options may be passed to the Template \fInew()\fR
constructor method and will be forwarded to the Template::Context
constructor.
.PP
.Vb 1
\&    use Template;
\&    
\&    my $template = Template\->new({
\&        TRIM      => 1,
\&        EVAL_PERL => 1,
\&        BLOCKS    => {
\&            header => 'This is the header',
\&            footer => 'This is the footer',
\&        },
\&    });
.Ve
.PP
Similarly, the Template::Context constructor will forward all configuration
parameters onto other default objects (e.g. Template::Provider, Template::Plugins,
Template::Filters, etc.) that it may need to instantiate.
.PP
.Vb 4
\&    $context = Template::Context\->new({
\&        INCLUDE_PATH => '/home/abw/templates', # provider option
\&        TAG_STYLE    => 'html',                # parser option
\&    });
.Ve
.PP
A Template::Context object (or subclass/derivative) can be explicitly
instantiated and passed to the Template \fInew()\fR constructor method as 
the \s-1CONTEXT\s0 item.
.PP
.Vb 2
\&    use Template;
\&    use Template::Context;
\&
\&    my $context  = Template::Context\->new({ TRIM => 1 });
\&    my $template = Template\->new({ CONTEXT => $context });
.Ve
.PP
The Template module uses the Template::Config \fIcontext()\fR factory method
to create a default context object when required.  The
\&\f(CW$Template::Config::CONTEXT\fR package variable may be set to specify an
alternate context module.  This will be loaded automatically and its
\&\fInew()\fR constructor method called by the \fIcontext()\fR factory method when
a default context object is required.
.PP
.Vb 1
\&    use Template;
\&
\&    $Template::Config::CONTEXT = 'MyOrg::Template::Context';
\&
\&    my $template = Template\->new({
\&        EVAL_PERL   => 1,
\&        EXTRA_MAGIC => 'red hot',  # your extra config items
\&        ...
\&    });
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "new(\e%params)"
.IX Subsection "new(%params)"
The \fInew()\fR constructor method is called to instantiate a Template::Context
object.  Configuration parameters may be specified as a \s-1HASH\s0 reference or
as a list of (name => value) pairs.
.PP
.Vb 4
\&    my $context = Template::Context\->new({
\&        INCLUDE_PATH => 'header',
\&        POST_PROCESS => 'footer',
\&    });
\&
\&    my $context = Template::Context\->new( EVAL_PERL => 1 );
.Ve
.PP
The \fInew()\fR method returns a Template::Context object (or sub-class) or
undef on error.  In the latter case, a relevant error message can be
retrieved by the \fIerror()\fR class method or directly from the
\&\f(CW$Template::Context::ERROR\fR package variable.
.PP
.Vb 2
\&    my $context = Template::Context\->new(\e%config)
\&        || die Template::Context\->error();
\&
\&    my $context = Template::Context\->new(\e%config)
\&        || die $Template::Context::ERROR;
.Ve
.PP
The following configuration items may be specified.
.IP "\s-1VARIABLES\s0, \s-1PRE_DEFINE\s0" 4
.IX Item "VARIABLES, PRE_DEFINE"
The \s-1VARIABLES\s0 option (or \s-1PRE_DEFINE\s0 \- they're equivalent) can be used
to specify a hash array of template variables that should be used to
pre-initialise the stash when it is created.  These items are ignored
if the \s-1STASH\s0 item is defined.
.Sp
.Vb 7
\&    my $context = Template::Context\->new({
\&        VARIABLES => {
\&            title   => 'A Demo Page',
\&            author  => 'Joe Random Hacker',
\&            version => 3.14,
\&        },
\&    };
.Ve
.Sp
or
.Sp
.Vb 7
\&    my $context = Template::Context\->new({
\&        PRE_DEFINE => {
\&            title   => 'A Demo Page',
\&            author  => 'Joe Random Hacker',
\&            version => 3.14,
\&        },
\&    };
.Ve
.IP "\s-1BLOCKS\s0" 4
.IX Item "BLOCKS"
The \s-1BLOCKS\s0 option can be used to pre-define a default set of template 
blocks.  These should be specified as a reference to a hash array 
mapping template names to template text, subroutines or Template::Document
objects.
.Sp
.Vb 7
\&    my $context = Template::Context\->new({
\&        BLOCKS => {
\&            header  => 'The Header.  [% title %]',
\&            footer  => sub { return $some_output_text },
\&            another => Template::Document\->new({ ... }),
\&        },
\&    });
.Ve
.IP "\s-1TRIM\s0" 4
.IX Item "TRIM"
The \s-1TRIM\s0 option can be set to have any leading and trailing whitespace 
automatically removed from the output of all template files and BLOCKs.
.Sp
By example, the following \s-1BLOCK\s0 definition
.Sp
.Vb 3
\&    [% BLOCK foo %]
\&    Line 1 of foo
\&    [% END %]
.Ve
.Sp
will be processed is as \*(L"\enLine 1 of foo\en\*(R".  When INCLUDEd, the surrounding
newlines will also be introduced.
.Sp
.Vb 3
\&    before 
\&    [% INCLUDE foo %]
\&    after
.Ve
.Sp
output:
    before
.Sp
.Vb 1
\&    Line 1 of foo
\&
\&    after
.Ve
.Sp
With the \s-1TRIM\s0 option set to any true value, the leading and trailing
newlines (which count as whitespace) will be removed from the output 
of the \s-1BLOCK\s0.
.Sp
.Vb 3
\&    before
\&    Line 1 of foo
\&    after
.Ve
.Sp
The \s-1TRIM\s0 option is disabled (0) by default.
.IP "\s-1EVAL_PERL\s0" 4
.IX Item "EVAL_PERL"
This flag is used to indicate if \s-1PERL\s0 and/or \s-1RAWPERL\s0 blocks should be
evaluated.  By default, it is disabled and any \s-1PERL\s0 or \s-1RAWPERL\s0 blocks
encountered will raise exceptions of type 'perl' with the message
\&'\s-1EVAL_PERL\s0 not set'.  Note however that any \s-1RAWPERL\s0 blocks should
always contain valid Perl code, regardless of the \s-1EVAL_PERL\s0 flag.  The
parser will fail to compile templates that contain invalid Perl code
in \s-1RAWPERL\s0 blocks and will throw a 'file' exception.
.Sp
When using compiled templates (see 
\&\s-1COMPILE_EXT\s0 and 
\&\s-1COMPILE_DIR\s0),
the \s-1EVAL_PERL\s0 has an affect when the template is compiled, and again
when the templates is subsequently processed, possibly in a different
context to the one that compiled it.
.Sp
If the \s-1EVAL_PERL\s0 is set when a template is compiled, then all \s-1PERL\s0 and
\&\s-1RAWPERL\s0 blocks will be included in the compiled template.  If the 
\&\s-1EVAL_PERL\s0 option isn't set, then Perl code will be generated which 
\&\fBalways\fR throws a 'perl' exception with the message '\s-1EVAL_PERL\s0 not
set' \fBwhenever\fR the compiled template code is run.
.Sp
Thus, you must have \s-1EVAL_PERL\s0 set if you want your compiled templates
to include \s-1PERL\s0 and \s-1RAWPERL\s0 blocks.
.Sp
At some point in the future, using a different invocation of the
Template Toolkit, you may come to process such a pre-compiled
template.  Assuming the \s-1EVAL_PERL\s0 option was set at the time the
template was compiled, then the output of any \s-1RAWPERL\s0 blocks will be
included in the compiled template and will get executed when the
template is processed.  This will happen regardless of the runtime
\&\s-1EVAL_PERL\s0 status.
.Sp
Regular \s-1PERL\s0 blocks are a little more cautious, however.  If the 
\&\s-1EVAL_PERL\s0 flag isn't set for the \fIcurrent\fR context, that is, the 
one which is trying to process it, then it will throw the familiar 'perl'
exception with the message, '\s-1EVAL_PERL\s0 not set'.
.Sp
Thus you can compile templates to include \s-1PERL\s0 blocks, but optionally
disable them when you process them later.  Note however that it is 
possible for a \s-1PERL\s0 block to contain a Perl \*(L"\s-1BEGIN\s0 { # some code }\*(R"
block which will always get run regardless of the runtime \s-1EVAL_PERL\s0
status.  Thus, if you set \s-1EVAL_PERL\s0 when compiling templates, it is
assumed that you trust the templates to Do The Right Thing.  Otherwise
you must accept the fact that there's no bulletproof way to prevent 
any included code from trampling around in the living room of the 
runtime environment, making a real nuisance of itself if it really
wants to.  If you don't like the idea of such uninvited guests causing
a bother, then you can accept the default and keep \s-1EVAL_PERL\s0 disabled.
.IP "\s-1RECURSION\s0" 4
.IX Item "RECURSION"
The template processor will raise a file exception if it detects
direct or indirect recursion into a template.  Setting this option to 
any true value will allow templates to include each other recursively.
.IP "\s-1LOAD_TEMPLATES\s0" 4
.IX Item "LOAD_TEMPLATES"
The \s-1LOAD_TEMPLATE\s0 option can be used to provide a reference to a list
of Template::Provider objects or sub-classes thereof which will take
responsibility for loading and compiling templates.
.Sp
.Vb 6
\&    my $context = Template::Context\->new({
\&        LOAD_TEMPLATES => [
\&            MyOrg::Template::Provider\->new({ ... }),
\&            Template::Provider\->new({ ... }),
\&        ],
\&    });
.Ve
.Sp
When a \s-1PROCESS\s0, \s-1INCLUDE\s0 or \s-1WRAPPER\s0 directive is encountered, the named
template may refer to a locally defined \s-1BLOCK\s0 or a file relative to
the \s-1INCLUDE_PATH\s0 (or an absolute or relative path if the appropriate
\&\s-1ABSOLUTE\s0 or \s-1RELATIVE\s0 options are set).  If a \s-1BLOCK\s0 definition can't be
found (see the Template::Context \fItemplate()\fR method for a discussion of
\&\s-1BLOCK\s0 locality) then each of the \s-1LOAD_TEMPLATES\s0 provider objects is
queried in turn via the \fIfetch()\fR method to see if it can supply the
required template.  Each provider can return a compiled template, an
error, or decline to service the request in which case the
responsibility is passed to the next provider.  If none of the
providers can service the request then a 'not found' error is
returned.  The same basic provider mechanism is also used for the 
\&\s-1INSERT\s0 directive but it bypasses any \s-1BLOCK\s0 definitions and doesn't
attempt is to parse or process the contents of the template file.
.Sp
This is an implementation of the 'Chain of Responsibility'
design pattern as described in 
\&\*(L"Design Patterns\*(R", Erich Gamma, Richard Helm, Ralph Johnson, John 
Vlissides), Addision-Wesley, \s-1ISBN\s0 0\-201\-63361\-2, page 223
\&.
.Sp
If \s-1LOAD_TEMPLATES\s0 is undefined, a single default provider will be
instantiated using the current configuration parameters.  For example,
the Template::Provider \s-1INCLUDE_PATH\s0 option can be specified in the Template::Context configuration and will be correctly passed to the provider's
constructor method.
.Sp
.Vb 3
\&    my $context = Template::Context\->new({
\&        INCLUDE_PATH => '/here:/there',
\&    });
.Ve
.IP "\s-1LOAD_PLUGINS\s0" 4
.IX Item "LOAD_PLUGINS"
The \s-1LOAD_PLUGINS\s0 options can be used to specify a list of provider
objects (i.e. they implement the \fIfetch()\fR method) which are responsible
for loading and instantiating template plugin objects.  The
Template::Content \fIplugin()\fR method queries each provider in turn in a
\&\*(L"Chain of Responsibility\*(R" as per the \fItemplate()\fR and \fIfilter()\fR methods.
.Sp
.Vb 6
\&    my $context = Template::Context\->new({
\&        LOAD_PLUGINS => [
\&            MyOrg::Template::Plugins\->new({ ... }),
\&            Template::Plugins\->new({ ... }),
\&        ],
\&    });
.Ve
.Sp
By default, a single Template::Plugins object is created using the 
current configuration hash.  Configuration items destined for the 
Template::Plugins constructor may be added to the Template::Context 
constructor.
.Sp
.Vb 4
\&    my $context = Template::Context\->new({
\&        PLUGIN_BASE => 'MyOrg::Template::Plugins',
\&        LOAD_PERL   => 1,
\&    });
.Ve
.IP "\s-1LOAD_FILTERS\s0" 4
.IX Item "LOAD_FILTERS"
The \s-1LOAD_FILTERS\s0 option can be used to specify a list of provider
objects (i.e. they implement the \fIfetch()\fR method) which are responsible
for returning and/or creating filter subroutines.  The
Template::Context \fIfilter()\fR method queries each provider in turn in a
\&\*(L"Chain of Responsibility\*(R" as per the \fItemplate()\fR and \fIplugin()\fR methods.
.Sp
.Vb 6
\&    my $context = Template::Context\->new({
\&        LOAD_FILTERS => [
\&            MyTemplate::Filters\->new(),
\&            Template::Filters\->new(),
\&        ],
\&    });
.Ve
.Sp
By default, a single Template::Filters object is created for the
\&\s-1LOAD_FILTERS\s0 list.
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
A reference to a Template::Stash object or sub-class which will take
responsibility for managing template variables.
.Sp
.Vb 4
\&    my $stash = MyOrg::Template::Stash\->new({ ... });
\&    my $context = Template::Context\->new({
\&        STASH => $stash,
\&    });
.Ve
.Sp
If unspecified, a default stash object is created using the \s-1VARIABLES\s0
configuration item to initialise the stash variables.  These may also
be specified as the \s-1PRE_DEFINE\s0 option for backwards compatibility with 
version 1.
.Sp
.Vb 6
\&    my $context = Template::Context\->new({
\&        VARIABLES => {
\&            id    => 'abw',
\&            name  => 'Andy Wardley',
\&        },
\&    };
.Ve
.IP "\s-1DEBUG\s0" 4
.IX Item "DEBUG"
The \s-1DEBUG\s0 option can be used to enable various debugging features
of the Template::Context module.
.Sp
.Vb 1
\&    use Template::Constants qw( :debug );
\&
\&    my $template = Template\->new({
\&        DEBUG => DEBUG_CONTEXT | DEBUG_DIRS,
\&    });
.Ve
.Sp
The \s-1DEBUG\s0 value can include any of the following.  Multiple values
should be combined using the logical \s-1OR\s0 operator, '|'.
.RS 4
.IP "\s-1DEBUG_CONTEXT\s0" 4
.IX Item "DEBUG_CONTEXT"
Enables general debugging messages for the
Template::Context module.
.IP "\s-1DEBUG_DIRS\s0" 4
.IX Item "DEBUG_DIRS"
This option causes the Template Toolkit to generate comments
indicating the source file, line and original text of each directive
in the template.  These comments are embedded in the template output
using the format defined in the \s-1DEBUG_FORMAT\s0 configuration item, or a
simple default format if unspecified.
.Sp
For example, the following template fragment:
.Sp
.Vb 1
\&    Hello World
.Ve
.Sp
would generate this output:
.Sp
.Vb 4
\&    ## input text line 1 :  ##
\&    Hello 
\&    ## input text line 2 : World ##
\&    World
.Ve
.RE
.RS 4
.RE
.Sh "template($name)"
.IX Subsection "template($name)"
Returns a compiled template by querying each of the \s-1LOAD_TEMPLATES\s0 providers
(instances of Template::Provider, or sub-class) in turn.
.PP
.Vb 1
\&    $template = $context\->template('header');
.Ve
.PP
On error, a Template::Exception object of type 'file' is thrown via
\&\fIdie()\fR.  This can be caught by enclosing the call to \fItemplate()\fR in an
eval block and examining $@.
.PP
.Vb 6
\&    eval {
\&        $template = $context\->template('header');
\&    };
\&    if ($@) {
\&        print "failed to fetch template: $@\en";
\&    }
.Ve
.Sh "plugin($name, \e@args)"
.IX Subsection "plugin($name, @args)"
Instantiates a plugin object by querying each of the \s-1LOAD_PLUGINS\s0
providers.  The default \s-1LOAD_PLUGINS\s0 provider is a Template::Plugins
object which attempts to load plugin modules, according the various
configuration items such as \s-1PLUGIN_BASE\s0, \s-1LOAD_PERL\s0, etc., and then
instantiate an object via \fInew()\fR.  A reference to a list of constructor
arguments may be passed as the second parameter.  These are forwarded
to the plugin constructor.
.PP
Returns a reference to a plugin (which is generally an object, but
doesn't have to be).  Errors are thrown as Template::Exception objects
of type 'plugin'.
.PP
.Vb 1
\&    $plugin = $context\->plugin('DBI', 'dbi:msql:mydbname');
.Ve
.ie n .Sh "filter($name, \e@args, $alias)"
.el .Sh "filter($name, \e@args, \f(CW$alias\fP)"
.IX Subsection "filter($name, @args, $alias)"
Instantiates a filter subroutine by querying the \s-1LOAD_FILTERS\s0 providers.
The default \s-1LOAD_FILTERS\s0 providers is a Template::Filters object.
Additional arguments may be passed by list reference along with an
optional alias under which the filter will be cached for subsequent
use.  The filter is cached under its own \f(CW$name\fR if \f(CW$alias\fR is undefined.
Subsequent calls to filter($name) will return the cached entry, if
defined.  Specifying arguments bypasses the caching mechanism and
always creates a new filter.  Errors are thrown as Template::Exception
objects of typre 'filter'.
.PP
.Vb 2
\&    # static filter (no args)
\&    $filter = $context\->filter('html');
\&
\&    # dynamic filter (args) aliased to 'padright'
\&    $filter = $context\->filter('format', '%60s', 'padright');
\&
\&    # retrieve previous filter via 'padright' alias
\&    $filter = $context\->filter('padright');
.Ve
.Sh "process($template, \e%vars)"
.IX Subsection "process($template, %vars)"
Processes a template named or referenced by the first parameter and returns
the output generated.  An optional reference to a hash array may be passed
as the second parameter, containing variable definitions which will be set
before the template is processed.  The template is processed in the current
context, with no localisation of variables performed.   Errors are thrown
as Template::Exception objects via \fIdie()\fR.
.PP
.Vb 1
\&    $output = $context\->process('header', { title => 'Hello World' });
.Ve
.Sh "include($template, \e%vars)"
.IX Subsection "include($template, %vars)"
Similar to \fIprocess()\fR above, but using localised variables.  Changes made to
any variables will only persist until the \fIinclude()\fR method completes.
.PP
.Vb 1
\&    $output = $context\->include('header', { title => 'Hello World' });
.Ve
.ie n .Sh "throw($error_type, $error_message, \e$output)"
.el .Sh "throw($error_type, \f(CW$error_message\fP, \e$output)"
.IX Subsection "throw($error_type, $error_message, $output)"
Raises an exception in the form of a Template::Exception object by
calling \fIdie()\fR.  This method may be passed a reference to an existing
Template::Exception object; a single value containing an error message
which is used to instantiate a Template::Exception of type 'undef'; or
a pair of values representing the exception type and info from which a
Template::Exception object is instantiated.  e.g.
.PP
.Vb 3
\&    $context\->throw($exception);
\&    $context\->throw("I'm sorry Dave, I can't do that");
\&    $context\->throw('denied', "I'm sorry Dave, I can't do that");
.Ve
.PP
The optional third parameter may be a reference to the current output
buffer.  This is then stored in the exception object when created,
allowing the catcher to examine and use the output up to the point at
which the exception was raised.
.PP
.Vb 3
\&    $output .= 'blah blah blah';
\&    $output .= 'more rhubarb';
\&    $context\->throw('yack', 'Too much yacking', \e$output);
.Ve
.Sh "catch($exception, \e$output)"
.IX Subsection "catch($exception, $output)"
Catches an exception thrown, either as a reference to a
Template::Exception object or some other value.  In the latter case,
the error string is promoted to a Template::Exception object of
\&'undef' type.  This method also accepts a reference to the current
output buffer which is passed to the Template::Exception constructor,
or is appended to the output buffer stored in an existing
Template::Exception object, if unique (i.e. not the same reference).
By this process, the correct state of the output buffer can be
reconstructed for simple or nested throws.
.ie n .Sh "define_block($name, $block)"
.el .Sh "define_block($name, \f(CW$block\fP)"
.IX Subsection "define_block($name, $block)"
Adds a new block definition to the internal \s-1BLOCKS\s0 cache.  The first 
argument should contain the name of the block and the second a reference
to a Template::Document object or template sub-routine, or template text
which is automatically compiled into a template sub-routine.  Returns
a true value (the sub-routine or Template::Document reference) on 
success or undef on failure.  The relevant error message can be 
retrieved by calling the \fIerror()\fR method.
.ie n .Sh "define_filter($name, \e&filter, $is_dynamic)"
.el .Sh "define_filter($name, \e&filter, \f(CW$is_dynamic\fP)"
.IX Subsection "define_filter($name, &filter, $is_dynamic)"
Adds a new filter definition by calling the \fIstore()\fR method on each of
the \s-1LOAD_FILTERS\s0 providers until accepted (in the usual case, this is
accepted straight away by the one and only Template::Filters
provider).  The first argument should contain the name of the filter
and the second a reference to a filter subroutine.  The optional 
third argument can be set to any true value to indicate that the 
subroutine is a dynamic filter factory.  Returns a true value or
throws a 'filter' exception on error.
.Sh "localise(\e%vars)"
.IX Subsection "localise(%vars)"
Clones the stash to create a context with localised variables.  Returns a 
reference to the newly cloned stash object which is also stored
internally.
.PP
.Vb 1
\&    $stash = $context\->localise();
.Ve
.Sh "\fIdelocalise()\fP"
.IX Subsection "delocalise()"
Restore the stash to its state prior to localisation.
.PP
.Vb 1
\&    $stash = $context\->delocalise();
.Ve
.Sh "visit(\e%blocks)"
.IX Subsection "visit(%blocks)"
This method is called by Template::Document objects immediately before
they process their content.  It is called to register any local \s-1BLOCK\s0
definitions with the context object so that they may be subsequently
delivered on request.
.Sh "\fIleave()\fP"
.IX Subsection "leave()"
Compliment to \fIvisit()\fR, above.  Called by Template::Document objects 
immediately after they process their content.
.Sh "\fIreset()\fP"
.IX Subsection "reset()"
Clears the local \s-1BLOCKS\s0 cache of any \s-1BLOCK\s0 definitions.  Any initial set of
\&\s-1BLOCKS\s0 specified as a configuration item to the constructor will be reinstated.
.Sh "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
An \s-1AUTOLOAD\s0 method provides access to context configuration items.
.PP
.Vb 4
\&    $stash     = $context\->stash();
\&    $tflag     = $context\->trim();
\&    $epflag    = $context\->eval_perl();
\&    ...
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org>
.PP
<http://wardley.org/|http://wardley.org/>
.SH "VERSION"
.IX Header "VERSION"
2.98, distributed as part of the
Template Toolkit version 2.19, released on 27 April 2007.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&  Copyright (C) 1996\-2007 Andy Wardley.  All Rights Reserved.
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Document, Template::Exception, Template::Filters, Template::Plugins, Template::Provider, Template::Service, Template::Stash
