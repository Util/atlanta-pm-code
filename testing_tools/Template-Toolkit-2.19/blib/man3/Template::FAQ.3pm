.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::FAQ 3"
.TH Template::FAQ 3 "2007-04-27" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::FAQ \- Frequently Asked Questions about the Template Toolkit
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "Template Toolkit Language"
.IX Header "Template Toolkit Language"
.Sh "Why doesn't [% a = b \s-1IF\s0 c %] work as expected?"
.IX Subsection "Why doesn't [% a = b IF c %] work as expected?"
Because the parser interprets it as
.PP
.Vb 1
\&    [% a = (b IF c) %]
.Ve
.PP
Do this instead:
.PP
.Vb 1
\&    [% SET a = b IF c %]
.Ve
.Sh "If I'm using \s-1TT\s0 to write out a \s-1TT\s0 template, is there a good way to escape [% and %]?"
.IX Subsection "If I'm using TT to write out a TT template, is there a good way to escape [% and %]?"
You can do this:
.PP
.Vb 3
\&  [% stag = "[\e%"
\&     etag = "%\e]"
\&  %]
.Ve
.PP
and then:
.PP
.Vb 1
\&  [% stag; 'hello'; etag %]
.Ve
.PP
Or something like:
.PP
.Vb 3
\&  [% TAGS [\- \-] %]
\&  [\- INCLUDE foo \-]   # is a directive
\&  [% INCLUDE foo %]   # not a directive, just plain text, passed through
.Ve
.Sh "How do I iterate over a hash?"
.IX Subsection "How do I iterate over a hash?"
This is covered in the Template::Manual::VMethods section
of the manual page.  A list of all the keys that are in the hash can
be obtained with the 'keys' virtual method.  You can then iterate
over that list and by looking up each key in turn get the value.
.PP
.Vb 3
\&    [% FOREACH key = product.keys %]
\&       [% key %] => [% product.$key %]
\&    [% END %]
.Ve
.SH "Plugins"
.IX Header "Plugins"
.Sh "How do I get the Table plugin to order data across rather than down?"
.IX Subsection "How do I get the Table plugin to order data across rather than down?"
Order the data into rows:
.PP
.Vb 3
\&     Steve     Karen     Jeff
\&     Brooklyn  Nantucket Fairfax
\&     NY        MA        VA
\& 
\&    [% USE table(data, rows=3) %]
.Ve
.PP
Then ask for each column
.PP
.Vb 1
\&    [% FOREACH column = table.cols %]
.Ve
.PP
And then print each item in the column going across the output rows
.PP
.Vb 3
\&    [% FOREACH item = column %]
\&        <td>[% item %]</td>
\&    [% END %]
.Ve
.Sh "Accessing Cookies"
.IX Subsection "Accessing Cookies"
Jeff Boes <jboes@nexcerpt.com> asks:
.PP
.Vb 2
\&    Does anyone have a quick\-n\-dirty approach to accessing 
\&    cookies from templates?
.Ve
.PP
Jonas Liljegren answers:
.PP
.Vb 1
\&    [% USE CGI %]
\&    
\&    <p>The value is [% CGI.cookie('cookie_name') | html %]
.Ve
.SH "Extending the Template Toolkit"
.IX Header "Extending the Template Toolkit"
.Sh "Can I serve templates from a database?"
.IX Subsection "Can I serve templates from a database?"
Short answer: yes, Chris Nandor has done this for Slash.  You need to 
subclass Template::Provider.  See the mailing list archives for further
info.
.Sh "Can I fetch templates via http?"
.IX Subsection "Can I fetch templates via http?"
To do the job properly, you should sublcass Template::Provider to 
Template::Provider::HTTP and use a \s-1PREFIX_MAP\s0 option to bind the 
\&'http' template prefix to that particular provider (you may want to 
go digging around in the \fIChanges\fR file around version 2.01 for 
more info on \s-1PREFIX_MAP\s0 \- it may not be properly documented anywhere
else...yet!).  e.g. (untested due to lack of existing \s-1HTTP\s0 Provider
\&\- patches welcome!).
.PP
.Vb 1
\&    use Template::Provider::HTTP;
\&
\&    my $file = Template::Provider( INCLUDE_PATH => [...] );
\&    my $http = Template::Provider::HTTP\->new(...);
\&    my $tt2  = Template\->new({
\&        LOAD_TEMPLATES => [ $file, $http ],
\&        PREFIX_MAP => {
\&            file    => '0',     # file:foo.html
\&            http    => '1',     # http:foo.html
\&            default => '0',     # foo.html => file:foo.html
\&        }
\&    });
.Ve
.PP
Now a template specified as:
.PP
.Vb 1
\&    [% INCLUDE foo %]
.Ve
.PP
will be served by the 'file' provider (the default).  Otherwise you 
can explicitly add a prefix:
.PP
.Vb 3
\&    [% INCLUDE file:foo.html %]
\&    [% INCLUDE http:foo.html %]
\&    [% INCLUDE http://www.xyz.com/tt2/header.tt2 %]
.Ve
.PP
This same principal can be used to create a \s-1DBI\s0 template provider.  e.g.
.PP
.Vb 1
\&    [% INCLUDE dbi:foo.html %]
.Ve
.PP
But similarly, alas, we don't yet have a \s-1DBI\s0 provider as part of the 
Template Toolkit.  There has been some talk on the mailing list about
efforts to develop \s-1DBI\s0 and/or \s-1HTTP\s0 providers but as yet no-one has 
stepped forward to take up the challenge...
.PP
In the mean time, Craig's post from the mailing list has some useful
pointers on how to acheive this using existing modules:
.PP
.Vb 3
\&    To: Adam Theo <adamtheo@theoretic.com> 
\&    From: Craig Barratt <craig@arraycomm.com>
\&    Date: Fri, 18 May 2001 17:06:59 \-0700
\&      
\&    > i was wondering if there is anyway to fetch a file using http:// or
\&    > ftp:// and include that?
\&      
\&    Here's one way.  Set the LOAD_PERL option:
\&      
\&        use Template;
\&     
\&        my $template = Template\->new({  
\&            LOAD_PERL => 1
\&        });  
\&        $template\->process("example.tt", { stdout => *STDOUT })
\&                                     || die $template\->error();
\&     
\&    and then use LWP::UserAgent and HTTP::Request:
\&     
\&        [% 
\&            USE ua = LWP.UserAgent; 
\&            ua.proxy("http", "http://your_proxy/");
\&            USE req = HTTP.Request("GET", "http://www.cpan.org");
\&            ua.request(req).content;
\&        \-%]
\&     
\&    For FTP use Net::FTP:
\&     
\&        [%   
\&            USE ftp = Net.FTP("ftp.cpan.org");
\&            x = ftp.login("anonymous", "me@here.there");
\&            x = ftp.cwd("/");
\&            x = ftp.get("welcome.msg", stdout);
\&            x = ftp.quit;
\&        \-%]
\&     
\&    Normally ftp.get would write the file into the current directory.
\&    Instead we pass stdout as a second argument so that it is written
\&    to stdout.  We set stdout to STDOUT in the variables we pass to
\&    process. 
\&     
\&    Craig
.Ve
.SH "Miscellaneous"
.IX Header "Miscellaneous"
.Sh "How can I find out the name of the main template being processed?"
.IX Subsection "How can I find out the name of the main template being processed?"
The \f(CW\*(C`template\*(C'\fR variable contains a reference to the
Template::Document object for the main template you're processing
(i.e. the one provided as the first argument to the Template \fIprocess()\fR
method).  The \f(CW\*(C`name\*(C'\fR method returns its name.
.PP
.Vb 1
\&    [% template.name %]     # e.g. index.html
.Ve
.Sh "How can I find out the name of the current template being processed?"
.IX Subsection "How can I find out the name of the current template being processed?"
The \f(CW\*(C`template\*(C'\fR variable always references the \fImain\fR template being processed.
So even if you call [% \s-1INCLUDE\s0 header %], and that calls [% \s-1INCLUDE\s0 menu %],
the \f(CW\*(C`template\*(C'\fR variable will be unchanged.
.PP
index.html:
.PP
.Vb 2
\&    [% template.name  %]     # index.html
\&    [% INCLUDE header %]
.Ve
.PP
header:
.PP
.Vb 2
\&    [% template.name  %]     # index.html
\&    [% INCLUDE menu   %]
.Ve
.PP
menu:
.PP
.Vb 1
\&    [% template.name  %]     # index.html
.Ve
.PP
In constrast, the \f(CW\*(C`component\*(C'\fR variable always references the \fIcurrent\fR
template being processed.
.PP
index.html
.PP
.Vb 2
\&    [% component.name %]     # index.html
\&    [% INCLUDE header %]
.Ve
.PP
header:
.PP
.Vb 2
\&    [% component.name %]     # header
\&    [% INCLUDE menu   %]
.Ve
.PP
menu:
.PP
.Vb 1
\&    [% component.name  %]     # menu
.Ve
.Sh "How do I print the modification time of the template or component?"
.IX Subsection "How do I print the modification time of the template or component?"
The \f(CW\*(C`template\*(C'\fR and \f(CW\*(C`component\*(C'\fR variables reference the main template
and the current template being processed (see previous questions).
The \f(CW\*(C`modtime\*(C'\fR method returns the modification time of the
corresponding template file as a number of seconds since the Unix
epoch (00:00:00 \s-1GMT\s0 1st January 1970).
.PP
This number doesn't mean much to anyone (except perhaps serious Unix
geeks) so you'll probably want to use the Date plugin to format it for
human consumption.
.PP
.Vb 1
\&    [% USE Date %]
\&
\&    [% template.name %] last modified [% Date.format(template.modtime) %]
.Ve
.Sh "How can I configure variables on a per-request basis?"
.IX Subsection "How can I configure variables on a per-request basis?"
One easy way to acheive this is to define a single \s-1PRE_PROCESS\s0 template which
loads in other configuration files based on variables defined or other 
conditions.
.PP
For example, my setup usually looks something like this:
.PP
.Vb 1
\&    PRE_PROCESS => 'config/main'
.Ve
.PP
config/main:
.PP
.Vb 2
\&    [%  DEFAULT  style   = 'text'
\&                 section =  template.section or 'home';
\&
\&        PROCESS  config/site
\&              +  config/urls
\&              +  config/macros
\&              + "config/style/$style"
\&              + "config/section/$section"
\&              + ...
\&    %]
.Ve
.PP
This allows me to set a single 'style' variable to control which config
file gets pre-processed to set my various style options (colours, img paths,
etc).  For example:
.PP
config/style/basic:
.PP
.Vb 2
\&    [%  style = {
\&            name = style    # save existing 'style' var as 'style.name'
\&
\&            # define various other style variables....
\&            col = {
\&                back => '#ffffff'
\&                text => '#000000'
\&                    # ...etc...
\&            }
\&
\&            logo = {
\&                    # ...etc...
\&            }
\&
\&            # ...etc...
\&        }
\&    %]
.Ve
.PP
Each source template can declare which section it's in via a \s-1META\s0
directive:
.PP
.Vb 4
\&  [% META
\&       title   = 'General Information'
\&       section = 'info'
\&  %]
\&
\&  ...
.Ve
.PP
This controls which section configuration file gets loaded to set various
other variables for defining the section title, menu, etc.
.PP
config/section/info:
.PP
.Vb 7
\&    [%  section = {
\&                name   = section  # save 'section' var as 'section.name'
\&                title  = 'Information'
\&                menu   = [ ... ]
\&                # ...etc...
\&            }
\&    %]
.Ve
.PP
This illustrates the basic principal but you can extend it to perform
pretty much any kind of per-document initialisation that you require.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org>
.PP
<http://wardley.org/|http://wardley.org/>
.SH "VERSION"
.IX Header "VERSION"
2.68, distributed as part of the
Template Toolkit version 2.19, released on 27 April 2007.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&  Copyright (C) 1996\-2007 Andy Wardley.  All Rights Reserved.
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
