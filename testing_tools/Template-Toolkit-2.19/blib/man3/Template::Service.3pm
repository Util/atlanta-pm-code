.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::Service 3"
.TH Template::Service 3 "2007-04-27" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Service \- General purpose template processing service
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Template::Service;
\&
\&    my $service = Template::Service\->new({
\&        PRE_PROCESS  => [ 'config', 'header' ],
\&        POST_PROCESS => 'footer',
\&        ERROR        => {
\&            user     => 'user/index.html', 
\&            dbi      => 'error/database',
\&            default  => 'error/default',
\&        },
\&    });
\&
\&    my $output = $service\->process($template_name, \e%replace)
\&        || die $service\->error(), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Template::Service module implements an object class for providing
a consistent template processing service.
.PP
Standard header (\s-1PRE_PROCESS\s0) and footer (\s-1POST_PROCESS\s0) templates may
be specified which are prepended and appended to all templates
processed by the service (but not any other templates or blocks
INCLUDEd or PROCESSed from within).  An \s-1ERROR\s0 hash may be specified
which redirects the service to an alternate template file in the case
of uncaught exceptions being thrown.  This allows errors to be
automatically handled by the service and a guaranteed valid response
to be generated regardless of any processing problems encountered.
.PP
A default Template::Service object is created by the Template module.
Any Template::Service options may be passed to the Template \fInew()\fR
constructor method and will be forwarded to the Template::Service
constructor.
.PP
.Vb 1
\&    use Template;
\&    
\&    my $template = Template\->new({
\&        PRE_PROCESS  => 'header',
\&        POST_PROCESS => 'footer',
\&    });
.Ve
.PP
Similarly, the Template::Service constructor will forward all configuration
parameters onto other default objects (e.g. Template::Context) that it may 
need to instantiate.
.PP
A Template::Service object (or subclass/derivative) can be explicitly
instantiated and passed to the Template \fInew()\fR constructor method as 
the \s-1SERVICE\s0 item.
.PP
.Vb 2
\&    use Template;
\&    use Template::Service;
\&
\&    my $service = Template::Service\->new({
\&        PRE_PROCESS  => 'header',
\&        POST_PROCESS => 'footer',
\&    });
\&
\&    my $template = Template\->new({
\&        SERVICE => $service,
\&    });
.Ve
.PP
The Template::Service module can be sub-classed to create custom service
handlers.
.PP
.Vb 2
\&    use Template;
\&    use MyOrg::Template::Service;
\&
\&    my $service = MyOrg::Template::Service\->new({
\&        PRE_PROCESS  => 'header',
\&        POST_PROCESS => 'footer',
\&        COOL_OPTION  => 'enabled in spades',
\&    });
\&
\&    my $template = Template\->new({
\&        SERVICE => $service,
\&    });
.Ve
.PP
The Template module uses the Template::Config \fIservice()\fR factory method
to create a default service object when required.  The
\&\f(CW$Template::Config::SERVICE\fR package variable may be set to specify an
alternate service module.  This will be loaded automatically and its
\&\fInew()\fR constructor method called by the \fIservice()\fR factory method when
a default service object is required.  Thus the previous example could 
be written as:
.PP
.Vb 1
\&    use Template;
\&
\&    $Template::Config::SERVICE = 'MyOrg::Template::Service';
\&
\&    my $template = Template\->new({
\&        PRE_PROCESS  => 'header',
\&        POST_PROCESS => 'footer',
\&        COOL_OPTION  => 'enabled in spades',
\&    });
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "new(\e%config)"
.IX Subsection "new(%config)"
The \fInew()\fR constructor method is called to instantiate a Template::Service
object.  Configuration parameters may be specified as a \s-1HASH\s0 reference or
as a list of (name => value) pairs.
.PP
.Vb 4
\&    my $service1 = Template::Service\->new({
\&        PRE_PROCESS  => 'header',
\&        POST_PROCESS => 'footer',
\&    });
\&
\&    my $service2 = Template::Service\->new( ERROR => 'error.html' );
.Ve
.PP
The \fInew()\fR method returns a Template::Service object (or sub-class) or
undef on error.  In the latter case, a relevant error message can be
retrieved by the \fIerror()\fR class method or directly from the
\&\f(CW$Template::Service::ERROR\fR package variable.
.PP
.Vb 2
\&    my $service = Template::Service\->new(\e%config)
\&        || die Template::Service\->error();
\&
\&    my $service = Template::Service\->new(\e%config)
\&        || die $Template::Service::ERROR;
.Ve
.PP
The following configuration items may be specified:
.IP "\s-1PRE_PROCESS\s0, \s-1POST_PROCESS\s0" 4
.IX Item "PRE_PROCESS, POST_PROCESS"
These values may be set to contain the name(s) of template files
(relative to \s-1INCLUDE_PATH\s0) which should be processed immediately
before and/or after each template.  These do not get added to 
templates processed into a document via directives such as \s-1INCLUDE\s0, 
\&\s-1PROCESS\s0, \s-1WRAPPER\s0 etc.
.Sp
.Vb 4
\&    my $service = Template::Service\->new({
\&        PRE_PROCESS  => 'header',
\&        POST_PROCESS => 'footer',
\&    };
.Ve
.Sp
Multiple templates may be specified as a reference to a list.  Each is 
processed in the order defined.
.Sp
.Vb 4
\&    my $service = Template::Service\->new({
\&        PRE_PROCESS  => [ 'config', 'header' ],
\&        POST_PROCESS => 'footer',
\&    };
.Ve
.Sp
Alternately, multiple template may be specified as a single string, 
delimited by ':'.  This delimiter string can be changed via the 
\&\s-1DELIMITER\s0 option.
.Sp
.Vb 4
\&    my $service = Template::Service\->new({
\&        PRE_PROCESS  => 'config:header',
\&        POST_PROCESS => 'footer',
\&    };
.Ve
.Sp
The \s-1PRE_PROCESS\s0 and \s-1POST_PROCESS\s0 templates are evaluated in the same
variable context as the main document and may define or update
variables for subsequent use.
.Sp
config:
.Sp
.Vb 4
\&    [% # set some site\-wide variables
\&       bgcolor = '#ffffff'
\&       version = 2.718
\&    %]
.Ve
.Sp
header:
.Sp
.Vb 6
\&    [% DEFAULT title = 'My Funky Web Site' %]
\&    <html>
\&    <head>
\&    <title>[% title %]</title>
\&    </head>
\&    <body bgcolor="[% bgcolor %]">
.Ve
.Sp
footer:
.Sp
.Vb 4
\&    <hr>
\&    Version [% version %]
\&    </body>
\&    </html>
.Ve
.Sp
The Template::Document object representing the main template being processed
is available within \s-1PRE_PROCESS\s0 and \s-1POST_PROCESS\s0 templates as the 'template'
variable.  Metadata items defined via the \s-1META\s0 directive may be accessed 
accordingly.
.Sp
.Vb 1
\&    $service\->process('mydoc.html', $vars);
.Ve
.Sp
mydoc.html:
.Sp
.Vb 3
\&    [% META title = 'My Document Title' %]
\&    blah blah blah
\&    ...
.Ve
.Sp
header:
.Sp
.Vb 4
\&    <html>
\&    <head>
\&    <title>[% template.title %]</title></head>
\&    <body bgcolor="[% bgcolor %]">
.Ve
.IP "\s-1PROCESS\s0" 4
.IX Item "PROCESS"
The \s-1PROCESS\s0 option may be set to contain the name(s) of template files
(relative to \s-1INCLUDE_PATH\s0) which should be processed instead of the 
main template passed to the Template::Service \fIprocess()\fR method.  This can 
be used to apply consistent wrappers around all templates, similar to 
the use of \s-1PRE_PROCESS\s0 and \s-1POST_PROCESS\s0 templates.
.Sp
.Vb 3
\&    my $service = Template::Service\->new({
\&        PROCESS  => 'content',
\&    };
\&
\&    # processes 'content' instead of 'foo.html'
\&    $service\->process('foo.html');
.Ve
.Sp
A reference to the original template is available in the 'template'
variable.  Metadata items can be inspected and the template can be
processed by specifying it as a variable reference (i.e. prefixed by
\&'$') to an \s-1INCLUDE\s0, \s-1PROCESS\s0 or \s-1WRAPPER\s0 directive.
.Sp
content:
.Sp
.Vb 4
\&    <html>
\&    <head>
\&    <title>[% template.title %]</title>
\&    </head>
\&    
\&    <body>
\&    [% PROCESS $template %]
\&    <hr>
\&    &copy; Copyright [% template.copyright %]
\&    </body>
\&    </html>
.Ve
.Sp
foo.html:
.Sp
.Vb 7
\&    [% META 
\&       title     = 'The Foo Page'
\&       author    = 'Fred Foo'
\&       copyright = '2000 Fred Foo'
\&    %]
\&    <h1>[% template.title %]</h1>
\&    Welcome to the Foo Page, blah blah blah
.Ve
.Sp
output:
.Sp
.Vb 4
\&    <html>
\&    <head>
\&    <title>The Foo Page</title>
\&    </head>
\&
\&    <body>
\&    <h1>The Foo Page</h1>
\&    Welcome to the Foo Page, blah blah blah
\&    <hr>
\&    &copy; Copyright 2000 Fred Foo
\&    </body>
\&    </html>
.Ve
.IP "\s-1ERROR\s0" 4
.IX Item "ERROR"
The \s-1ERROR\s0 (or \s-1ERRORS\s0 if you prefer) configuration item can be used to
name a single template or specify a hash array mapping exception types
to templates which should be used for error handling.  If an uncaught
exception is raised from within a template then the appropriate error
template will instead be processed.
.Sp
If specified as a single value then that template will be processed 
for all uncaught exceptions.
.Sp
.Vb 3
\&    my $service = Template::Service\->new({
\&        ERROR => 'error.html'
\&    });
.Ve
.Sp
If the \s-1ERROR\s0 item is a hash reference the keys are assumed to be
exception types and the relevant template for a given exception will
be selected.  A 'default' template may be provided for the general
case.  Note that '\s-1ERROR\s0' can be pluralised to '\s-1ERRORS\s0' if you find
it more appropriate in this case.
.Sp
.Vb 7
\&    my $service = Template::Service\->new({
\&        ERRORS => {
\&            user     => 'user/index.html',
\&            dbi      => 'error/database',
\&            default  => 'error/default',
\&        },
\&    });
.Ve
.Sp
In this example, any 'user' exceptions thrown will cause the
\&'user/index.html' template to be processed, 'dbi' errors are handled
by 'error/database' and all others by the 'error/default' template.
Any \s-1PRE_PROCESS\s0 and/or \s-1POST_PROCESS\s0 templates will also be applied
to these error templates.
.Sp
Note that exception types are hierarchical and a 'foo' handler will
catch all 'foo.*' errors (e.g. foo.bar, foo.bar.baz) if a more
specific handler isn't defined.  Be sure to quote any exception types
that contain periods to prevent Perl concatenating them into a single
string (i.e. \f(CW\*(C`user.passwd\*(C'\fR is parsed as 'user'.'passwd').
.Sp
.Vb 8
\&    my $service = Template::Service\->new({
\&        ERROR => {
\&            'user.login'  => 'user/login.html',
\&            'user.passwd' => 'user/badpasswd.html',
\&            'user'        => 'user/index.html',
\&            'default'     => 'error/default',
\&        },
\&    });
.Ve
.Sp
In this example, any template processed by the \f(CW$service\fR object, or
other templates or code called from within, can raise a 'user.login'
exception and have the service redirect to the 'user/login.html'
template.  Similarly, a 'user.passwd' exception has a specific 
handling template, 'user/badpasswd.html', while all other 'user' or
\&'user.*' exceptions cause a redirection to the 'user/index.html' page.
All other exception types are handled by 'error/default'.
.Sp
Exceptions can be raised in a template using the \s-1THROW\s0 directive,
.Sp
.Vb 1
\&    [% THROW user.login 'no user id: please login' %]
.Ve
.Sp
or by calling the \fIthrow()\fR method on the current Template::Context object,
.Sp
.Vb 2
\&    $context\->throw('user.passwd', 'Incorrect Password');
\&    $context\->throw('Incorrect Password');    # type 'undef'
.Ve
.Sp
or from Perl code by calling \fIdie()\fR with a Template::Exception object,
.Sp
.Vb 1
\&    die (Template::Exception\->new('user.denied', 'Invalid User ID'));
.Ve
.Sp
or by simply calling \fIdie()\fR with an error string.  This is
automagically caught and converted to an  exception of 'undef'
type which can then be handled in the usual way.
.Sp
.Vb 1
\&    die "I'm sorry Dave, I can't do that";
.Ve
.IP "\s-1AUTO_RESET\s0" 4
.IX Item "AUTO_RESET"
The \s-1AUTO_RESET\s0 option is set by default and causes the local \s-1BLOCKS\s0
cache for the Template::Context object to be reset on each call to the
Template \fIprocess()\fR method.  This ensures that any BLOCKs defined
within a template will only persist until that template is finished
processing.  This prevents BLOCKs defined in one processing request
from interfering with other independent requests subsequently
processed by the same context object.
.Sp
The \s-1BLOCKS\s0 item may be used to specify a default set of block definitions
for the Template::Context object.  Subsequent \s-1BLOCK\s0 definitions in templates
will over-ride these but they will be reinstated on each reset if \s-1AUTO_RESET\s0
is enabled (default), or if the Template::Context \fIreset()\fR method is called.
.IP "\s-1DEBUG\s0" 4
.IX Item "DEBUG"
The \s-1DEBUG\s0 option can be used to enable debugging messages from the
Template::Service module by setting it to include the \s-1DEBUG_SERVICE\s0
value.
.Sp
.Vb 1
\&    use Template::Constants qw( :debug );
\&
\&    my $template = Template\->new({
\&        DEBUG => DEBUG_SERVICE,
\&    });
.Ve
.Sh "process($input, \e%replace)"
.IX Subsection "process($input, %replace)"
The \fIprocess()\fR method is called to process a template specified as the first
parameter, \f(CW$input\fR.  This may be a file name, file handle (e.g. \s-1GLOB\s0 or IO::Handle)
or a reference to a text string containing the template text.  An additional
hash reference may be passed containing template variable definitions.
.PP
The method processes the template, adding any \s-1PRE_PROCESS\s0 or \s-1POST_PROCESS\s0 
templates defined, and returns the output text.  An uncaught exception thrown 
by the template will be handled by a relevant \s-1ERROR\s0 handler if defined.
Errors that occur in the \s-1PRE_PROCESS\s0 or \s-1POST_PROCESS\s0 templates, or those that
occur in the main input template and aren't handled, cause the method to 
return undef to indicate failure.  The appropriate error message can be
retrieved via the \fIerror()\fR method.
.PP
.Vb 2
\&    $service\->process('myfile.html', { title => 'My Test File' })
\&        || die $service\->error();
.Ve
.Sh "\fIcontext()\fP"
.IX Subsection "context()"
Returns a reference to the internal context object which is, by default, an
instance of the Template::Context class.
.Sh "\fIerror()\fP"
.IX Subsection "error()"
Returns the most recent error message.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org>
.PP
<http://wardley.org/|http://wardley.org/>
.SH "VERSION"
.IX Header "VERSION"
2.93, distributed as part of the
Template Toolkit version 2.19, released on 27 April 2007.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&  Copyright (C) 1996\-2007 Andy Wardley.  All Rights Reserved.
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Context
