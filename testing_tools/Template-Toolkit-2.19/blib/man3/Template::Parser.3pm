.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Template::Parser 3"
.TH Template::Parser 3 "2007-04-27" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Parser \- LALR(1) parser for compiling template documents
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Template::Parser;
\&
\&    $parser   = Template::Parser\->new(\e%config);
\&    $template = $parser\->parse($text)
\&        || die $parser\->error(), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Template::Parser module implements a \s-1\fILALR\s0\fR\|(1) parser and associated methods
for parsing template documents into Perl code.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.Sh "new(\e%params)"
.IX Subsection "new(%params)"
The \fInew()\fR constructor creates and returns a reference to a new 
Template::Parser object.  A reference to a hash may be supplied as a 
parameter to provide configuration values.  These may include:
.IP "\s-1START_TAG\s0, \s-1END_TAG\s0" 4
.IX Item "START_TAG, END_TAG"
The \s-1START_TAG\s0 and \s-1END_TAG\s0 options are used to specify character
sequences or regular expressions that mark the start and end of a
template directive.  The default values for \s-1START_TAG\s0 and \s-1END_TAG\s0 are
\&'[%' and '%]' respectively, giving us the familiar directive style:
.Sp
.Vb 1
\&    [% example %]
.Ve
.Sp
Any Perl regex characters can be used and therefore should be escaped
(or use the Perl \f(CW\*(C`quotemeta\*(C'\fR function) if they are intended to
represent literal characters.
.Sp
.Vb 4
\&    my $parser = Template::Parser\->new({ 
\&        START_TAG => quotemeta('<+'),
\&        END_TAG   => quotemeta('+>'),
\&    });
.Ve
.Sp
example:
.Sp
.Vb 1
\&    <+ INCLUDE foobar +>
.Ve
.Sp
The \s-1TAGS\s0 directive can also be used to set the \s-1START_TAG\s0 and \s-1END_TAG\s0 values
on a per-template file basis.
.Sp
.Vb 1
\&    [% TAGS <+ +> %]
.Ve
.IP "\s-1TAG_STYLE\s0" 4
.IX Item "TAG_STYLE"
The \s-1TAG_STYLE\s0 option can be used to set both \s-1START_TAG\s0 and \s-1END_TAG\s0
according to pre-defined tag styles.
.Sp
.Vb 3
\&    my $parser = Template::Parser\->new({ 
\&        TAG_STYLE => 'star',
\&    });
.Ve
.Sp
Available styles are:
.Sp
.Vb 8
\&    template    [% ... %]               (default)
\&    template1   [% ... %] or %% ... %%  (TT version 1)
\&    metatext    %% ... %%               (Text::MetaText)
\&    star        [* ... *]               (TT alternate)
\&    php         <? ... ?>               (PHP)
\&    asp         <% ... %>               (ASP)
\&    mason       <% ...  >               (HTML::Mason)
\&    html        <!\-\- ... \-\->            (HTML comments)
.Ve
.Sp
Any values specified for \s-1START_TAG\s0 and/or \s-1END_TAG\s0 will over-ride
those defined by a \s-1TAG_STYLE\s0.
.Sp
The \s-1TAGS\s0 directive may also be used to set a \s-1TAG_STYLE\s0
.Sp
.Vb 2
\&    [% TAGS html %]
\&    <!\-\- INCLUDE header \-\->
.Ve
.IP "\s-1PRE_CHOMP\s0, \s-1POST_CHOMP\s0" 4
.IX Item "PRE_CHOMP, POST_CHOMP"
Anything outside a directive tag is considered plain text and is
generally passed through unaltered (but see the \s-1INTERPOLATE\s0 option).
This includes all whitespace and newlines characters surrounding
directive tags.  Directives that don't generate any output will leave
gaps in the output document.
.Sp
Example:
.Sp
.Vb 3
\&    Foo
\&    [% a = 10 %]
\&    Bar
.Ve
.Sp
Output:
.Sp
.Vb 1
\&    Foo
\&
\&    Bar
.Ve
.Sp
The \s-1PRE_CHOMP\s0 and \s-1POST_CHOMP\s0 options can help to clean up some of this
extraneous whitespace.  Both are disabled by default.
.Sp
.Vb 4
\&    my $parser = Template::Parser\-E<gt>new({
\&        PRE_CHOMP  =E<gt> 1,
\&        POST_CHOMP =E<gt> 1,
\&    });
.Ve
.Sp
With \s-1PRE_CHOMP\s0 set to 1, the newline and whitespace preceding a directive
at the start of a line will be deleted.  This has the effect of 
concatenating a line that starts with a directive onto the end of the 
previous line.
.Sp
.Vb 9
\&        Foo E<lt>\-\-\-\-\-\-\-\-\-\-.
\&                       |
\&    ,\-\-\-(PRE_CHOMP)\-\-\-\-'
\&    |
\&    `\-\- [% a = 10 %] \-\-.
\&                       |
\&    ,\-\-\-(POST_CHOMP)\-\-\-'
\&    |
\&    `\-E<gt> Bar
.Ve
.Sp
With \s-1POST_CHOMP\s0 set to 1, any whitespace after a directive up to and
including the newline will be deleted.  This has the effect of joining
a line that ends with a directive onto the start of the next line.
.Sp
If \s-1PRE_CHOMP\s0 or \s-1POST_CHOMP\s0 is set to 2, all whitespace including any
number of newline will be removed and replaced with a single space.
This is useful for \s-1HTML\s0, where (usually) a contiguous block of
whitespace is rendered the same as a single space.
.Sp
With \s-1PRE_CHOMP\s0 or \s-1POST_CHOMP\s0 set to 3, all adjacent whitespace
(including newlines) will be removed entirely.
.Sp
These values are defined as \s-1CHOMP_NONE\s0, \s-1CHOMP_ONE\s0, \s-1CHOMP_COLLAPSE\s0 and
\&\s-1CHOMP_GREEDY\s0 constants in the Template::Constants module.  \s-1CHOMP_ALL\s0
is also defined as an alias for \s-1CHOMP_ONE\s0 to provide backwards
compatability with earlier version of the Template Toolkit.
.Sp
Additionally the chomp tag modifiers listed below may also be used for
the \s-1PRE_CHOMP\s0 and \s-1POST_CHOMP\s0 configuration.
.Sp
.Vb 4
\&     my $template = Template\-E<gt>new({
\&        PRE_CHOMP  =E<lt> '~',
\&        POST_CHOMP =E<gt> '\-',
\&     });
.Ve
.Sp
\&\s-1PRE_CHOMP\s0 and \s-1POST_CHOMP\s0 can be activated for individual directives by
placing a '\-' immediately at the start and/or end of the directive.
.Sp
.Vb 3
\&    [% FOREACH user IN userlist %]
\&       [%\- user \-%]
\&    [% END %]
.Ve
.Sp
This has the same effect as \s-1CHOMP_ONE\s0 in removing all whitespace
before or after the directive up to and including the newline.  The
template will be processed as if written:
.Sp
.Vb 1
\&    [% FOREACH user IN userlist %][% user %][% END %]
.Ve
.Sp
To remove all whitespace including any number of newlines, use the '~' 
character instead.
.Sp
.Vb 1
\&    [% FOREACH user IN userlist %]
\&    
\&       [%~ user ~%]
\&    
\&    [% END %]
.Ve
.Sp
To collapse all whitespace to a single space, use the '=' character.
.Sp
.Vb 1
\&    [% FOREACH user IN userlist %]
\& 
\&       [%= user =%]
\&    
\&    [% END %]
.Ve
.Sp
Here the template is processed as if written:
.Sp
.Vb 1
\&    [% FOREACH user IN userlist %] [% user %] [% END %]
.Ve
.Sp
If you have \s-1PRE_CHOMP\s0 or \s-1POST_CHOMP\s0 set as configuration options then
you can use '+' to disable any chomping options (i.e.  leave the
whitespace intact) on a per-directive basis.
.Sp
.Vb 3
\&    [% FOREACH user = userlist %]
\&    User: [% user +%]
\&    [% END %]
.Ve
.Sp
With \s-1POST_CHOMP\s0 set to \s-1CHOMP_ONE\s0, the above example would be parsed as
if written:
.Sp
.Vb 2
\&    [% FOREACH user = userlist %]User: [% user %]
\&    [% END %]
.Ve
.Sp
For reference, the \s-1PRE_CHOMP\s0 and \s-1POST_CHOMP\s0 configuration options may be set to any of the following:
.Sp
.Vb 6
\&     Constant      Value   Tag Modifier
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     CHOMP_NONE      0          +
\&     CHOMP_ONE       1          \-
\&     CHOMP_COLLAPSE  2          =
\&     CHOMP_GREEDY    3          ~
.Ve
.IP "\s-1INTERPOLATE\s0" 4
.IX Item "INTERPOLATE"
The \s-1INTERPOLATE\s0 flag, when set to any true value will cause variable 
references in plain text (i.e. not surrounded by \s-1START_TAG\s0 and \s-1END_TAG\s0)
to be recognised and interpolated accordingly.
.Sp
.Vb 3
\&    my $parser = Template::Parser\->new({ 
\&        INTERPOLATE => 1,
\&    });
.Ve
.Sp
Variables should be prefixed by a '$' to identify them.  Curly braces
can be used in the familiar Perl/shell style to explicitly scope the
variable name where required.
.Sp
.Vb 4
\&    # INTERPOLATE => 0
\&    <a href="http://[% server %]/[% help %]">
\&    <img src="[% images %]/help.gif"></a>
\&    [% myorg.name %]
\&  
\&    # INTERPOLATE => 1
\&    <a href="http://$server/$help">
\&    <img src="$images/help.gif"></a>
\&    $myorg.name
\&  
\&    # explicit scoping with {  }
\&    <img src="$images/${icon.next}.gif">
.Ve
.Sp
Note that a limitation in Perl's regex engine restricts the maximum length
of an interpolated template to around 32 kilobytes or possibly less.  Files
that exceed this limit in size will typically cause Perl to dump core with
a segmentation fault.  If you routinely process templates of this size 
then you should disable \s-1INTERPOLATE\s0 or split the templates in several 
smaller files or blocks which can then be joined backed together via 
\&\s-1PROCESS\s0 or \s-1INCLUDE\s0.
.IP "\s-1ANYCASE\s0" 4
.IX Item "ANYCASE"
By default, directive keywords should be expressed in \s-1UPPER\s0 \s-1CASE\s0.  The 
\&\s-1ANYCASE\s0 option can be set to allow directive keywords to be specified
in any case.
.Sp
.Vb 4
\&    # ANYCASE => 0 (default)
\&    [% INCLUDE foobar %]        # OK
\&    [% include foobar %]        # ERROR
\&    [% include = 10   %]        # OK, 'include' is a variable
\&
\&    # ANYCASE => 1
\&    [% INCLUDE foobar %]        # OK
\&    [% include foobar %]        # OK
\&    [% include = 10   %]        # ERROR, 'include' is reserved word
.Ve
.Sp
One side-effect of enabling \s-1ANYCASE\s0 is that you cannot use a variable
of the same name as a reserved word, regardless of case.  The reserved
words are currently:
.Sp
.Vb 5
\&        GET CALL SET DEFAULT INSERT INCLUDE PROCESS WRAPPER 
\&    IF UNLESS ELSE ELSIF FOR FOREACH WHILE SWITCH CASE
\&    USE PLUGIN FILTER MACRO PERL RAWPERL BLOCK META
\&    TRY THROW CATCH FINAL NEXT LAST BREAK RETURN STOP 
\&    CLEAR TO STEP AND OR NOT MOD DIV END
.Ve
.Sp
The only lower case reserved words that cannot be used for variables,
regardless of the \s-1ANYCASE\s0 option, are the operators:
.Sp
.Vb 1
\&    and or not mod div
.Ve
.IP "V1DOLLAR" 4
.IX Item "V1DOLLAR"
In version 1 of the Template Toolkit, an optional leading '$' could be placed
on any template variable and would be silently ignored.
.Sp
.Vb 3
\&    # VERSION 1
\&    [% $foo %]       ===  [% foo %]
\&    [% $hash.$key %] ===  [% hash.key %]
.Ve
.Sp
To interpolate a variable value the '${' ... '}' construct was used.
Typically, one would do this to index into a hash array when the key
value was stored in a variable.
.Sp
example:
.Sp
.Vb 9
\&    my $vars = {
\&        users => {
\&            aba => { name => 'Alan Aardvark', ... },
\&            abw => { name => 'Andy Wardley', ... },
\&            ...
\&        },
\&        uid => 'aba',
\&        ...
\&    };
\&
\&    $template\->process('user/home.html', $vars)
\&        || die $template\->error(), "\en";
.Ve
.Sp
\&'user/home.html':
.Sp
.Vb 2
\&    [% user = users.${uid} %]     # users.aba
\&    Name: [% user.name %]         # Alan Aardvark
.Ve
.Sp
This was inconsistent with double quoted strings and also the
\&\s-1INTERPOLATE\s0 mode, where a leading '$' in text was enough to indicate a
variable for interpolation, and the additional curly braces were used
to delimit variable names where necessary.  Note that this use is
consistent with \s-1UNIX\s0 and Perl conventions, among others.
.Sp
.Vb 2
\&    # double quoted string interpolation
\&    [% name = "$title ${user.name}" %]
\&
\&    # INTERPOLATE = 1
\&    <img src="$images/help.gif"></a>
\&    <img src="$images/${icon.next}.gif">
.Ve
.Sp
For version 2, these inconsistencies have been removed and the syntax
clarified.  A leading '$' on a variable is now used exclusively to
indicate that the variable name should be interpolated
(e.g. subsituted for its value) before being used.  The earlier example
from version 1:
.Sp
.Vb 3
\&    # VERSION 1
\&    [% user = users.${uid} %]
\&    Name: [% user.name %]
.Ve
.Sp
can now be simplified in version 2 as:
.Sp
.Vb 3
\&    # VERSION 2
\&    [% user = users.$uid %]
\&    Name: [% user.name %]
.Ve
.Sp
The leading dollar is no longer ignored and has the same effect of
interpolation as '${' ... '}' in version 1.  The curly braces may
still be used to explicitly scope the interpolated variable name
where necessary.
.Sp
e.g.
.Sp
.Vb 2
\&    [% user = users.${me.id} %]
\&    Name: [% user.name %]
.Ve
.Sp
The rule applies for all variables, both within directives and in
plain text if processed with the \s-1INTERPOLATE\s0 option.  This means that
you should no longer (if you ever did) add a leading '$' to a variable
inside a directive, unless you explicitly want it to be interpolated.
.Sp
One obvious side-effect is that any version 1 templates with variables
using a leading '$' will no longer be processed as expected.  Given
the following variable definitions,
.Sp
.Vb 3
\&    [% foo = 'bar'
\&       bar = 'baz'
\&    %]
.Ve
.Sp
version 1 would interpret the following as:
.Sp
.Vb 2
\&    # VERSION 1
\&    [% $foo %] => [% GET foo %] => bar
.Ve
.Sp
whereas version 2 interprets it as:
.Sp
.Vb 2
\&    # VERSION 2
\&    [% $foo %] => [% GET $foo %] => [% GET bar %] => baz
.Ve
.Sp
In version 1, the '$' is ignored and the value for the variable 'foo' is 
retrieved and printed.  In version 2, the variable '$foo' is first interpolated
to give the variable name 'bar' whose value is then retrieved and printed.
.Sp
The use of the optional '$' has never been strongly recommended, but
to assist in backwards compatibility with any version 1 templates that
may rely on this \*(L"feature\*(R", the V1DOLLAR option can be set to 1
(default: 0) to revert the behaviour and have leading '$' characters
ignored.
.Sp
.Vb 3
\&    my $parser = Template::Parser\->new({
\&        V1DOLLAR => 1,
\&    });
.Ve
.IP "\s-1GRAMMAR\s0" 4
.IX Item "GRAMMAR"
The \s-1GRAMMAR\s0 configuration item can be used to specify an alternate
grammar for the parser.  This allows a modified or entirely new
template language to be constructed and used by the Template Toolkit.
.Sp
Source templates are compiled to Perl code by the Template::Parser
using the Template::Grammar (by default) to define the language
structure and semantics.  Compiled templates are thus inherently
\&\*(L"compatible\*(R" with each other and there is nothing to prevent any
number of different template languages being compiled and used within
the same Template Toolkit processing environment (other than the usual
time and memory constraints).
.Sp
The Template::Grammar file is constructed from a \s-1YACC\s0 like grammar
(using Parse::YAPP) and a skeleton module template.  These files are
provided, along with a small script to rebuild the grammar, in the
\&'parser' sub-directory of the distribution.  You don't have to know or
worry about these unless you want to hack on the template language or
define your own variant.  There is a \s-1README\s0 file in the same directory
which provides some small guidance but it is assumed that you know
what you're doing if you venture herein.  If you grok \s-1LALR\s0 parsers,
then you should find it comfortably familiar.
.Sp
By default, an instance of the default Template::Grammar will be
created and used automatically if a \s-1GRAMMAR\s0 item isn't specified.
.Sp
.Vb 1
\&    use MyOrg::Template::Grammar;
\&
\&    my $parser = Template::Parser\->new({ 
\&        GRAMMAR = MyOrg::Template::Grammar\->new();
\&    });
.Ve
.IP "\s-1DEBUG\s0" 4
.IX Item "DEBUG"
The \s-1DEBUG\s0 option can be used to enable various debugging features
of the Template::Parser module.
.Sp
.Vb 1
\&    use Template::Constants qw( :debug );
\&
\&    my $template = Template\->new({
\&        DEBUG => DEBUG_PARSER | DEBUG_DIRS,
\&    });
.Ve
.Sp
The \s-1DEBUG\s0 value can include any of the following.  Multiple values
should be combined using the logical \s-1OR\s0 operator, '|'.
.RS 4
.IP "\s-1DEBUG_PARSER\s0" 4
.IX Item "DEBUG_PARSER"
This flag causes the Template::Parser to generate
debugging messages that show the Perl code generated by parsing and
compiling each template.
.IP "\s-1DEBUG_DIRS\s0" 4
.IX Item "DEBUG_DIRS"
This option causes the Template Toolkit to generate comments
indicating the source file, line and original text of each directive
in the template.  These comments are embedded in the template output
using the format defined in the \s-1DEBUG_FORMAT\s0 configuration item, or a
simple default format if unspecified.
.Sp
For example, the following template fragment:
.Sp
.Vb 1
\&    Hello World
.Ve
.Sp
would generate this output:
.Sp
.Vb 4
\&    ## input text line 1 :  ##
\&    Hello 
\&    ## input text line 2 : World ##
\&    World
.Ve
.RE
.RS 4
.RE
.Sh "parse($text)"
.IX Subsection "parse($text)"
The \fIparse()\fR method parses the text passed in the first parameter and
returns a reference to a hash array of data defining the compiled
representation of the template text, suitable for passing to the
Template::Document \fInew()\fR constructor method.  On error, undef is
returned.
.PP
Example:
.PP
.Vb 2
\&    $data = $parser\->parse($text)
\&        || die $parser\->error();
.Ve
.PP
The \f(CW$data\fR hash reference returned contains a \s-1BLOCK\s0 item containing the
compiled Perl code for the template, a \s-1DEFBLOCKS\s0 item containing a
reference to a hash array of sub-template BLOCKs defined within in the
template, and a \s-1METADATA\s0 item containing a reference to a hash array
of metadata values defined in \s-1META\s0 tags.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org>
.PP
<http://wardley.org/|http://wardley.org/>
.SH "VERSION"
.IX Header "VERSION"
2.89, distributed as part of the
Template Toolkit version 2.19, released on 27 April 2007.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&  Copyright (C) 1996\-2007 Andy Wardley.  All Rights Reserved.
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
The original Template::Parser module was derived from a standalone
parser generated by version 0.16 of the Parse::Yapp module.  The
following copyright notice appears in the Parse::Yapp documentation.
.PP
.Vb 3
\&    The Parse::Yapp module and its related modules and shell
\&    scripts are copyright (c) 1998 Francois Desarmenien,
\&    France. All rights reserved.
\&
\&    You may use and distribute them under the terms of either
\&    the GNU General Public License or the Artistic License, as
\&    specified in the Perl README file.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Grammar, Template::Directive
